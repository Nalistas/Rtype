\chapter{README}
\hypertarget{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README}{}\label{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README}\index{README@{README}}
\href{https://github.com/medikoo/esniff/actions?query=workflow\%3AIntegrate}{\texttt{ }} \href{https://codecov.io/gh/medikoo/esniff}{\texttt{ }} \href{https://www.npmjs.com/package/esniff}{\texttt{ }}\hypertarget{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2442}{}\doxysection{\texorpdfstring{esniff}{esniff}}\label{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2442}
\hypertarget{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2443}{}\doxysubsection{\texorpdfstring{Low footprint Java\+Script source code parser}{Low footprint Java\+Script source code parser}}\label{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2443}
Low footprint, fast source code parser, which allows you to find all code fragment occurrences with respect to all syntax rules that cannot be handled with plain regular expression search.

It aims at use cases where we don\textquotesingle{}t need full AST tree, but instead we\textquotesingle{}re interested in finding usages of given function, property etc. in syntactically valid code.\hypertarget{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2444}{}\doxysubsubsection{\texorpdfstring{Installation}{Installation}}\label{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2444}
\hypertarget{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2445}{}\doxyparagraph{\texorpdfstring{npm}{npm}}\label{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2445}
\begin{DoxyVerb}$ npm install esniff
\end{DoxyVerb}
 \hypertarget{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2446}{}\doxysubsubsection{\texorpdfstring{Usage}{Usage}}\label{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2446}
Using main module you can configure sophisticated parser on your own. However, first, {\bfseries{see preprared API utilities that may already address use cases you have}}.\hypertarget{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2447}{}\doxyparagraph{\texorpdfstring{esniff(code, executor)}{esniff(code, executor)}}\label{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2447}

\begin{DoxyItemize}
\item {\ttfamily code} -\/ Code to parse
\item {\ttfamily executor} -\/ A function to be executed immediately by the constructor, It receives an {\ttfamily emitter} parameter.
\end{DoxyItemize}

{\ttfamily emitter} emits following events\+:


\begin{DoxyItemize}
\item {\ttfamily trigger\+:\texorpdfstring{$<$}{<}char\texorpdfstring{$>$}{>}} -\/ When char is a code character approached in code, that is not a whitespaces, is not in a middle of identificator, is not part of a comment, string, template string or regular expression.
\end{DoxyItemize}

Emitter passes to listener and {\ttfamily accessor} object, which provides access to current parser state and allows to manipulate parsing process. {\ttfamily accessor} exposes following methods\+:


\begin{DoxyItemize}
\item {\ttfamily skip\+Code\+Part(code\+Part)} -\/ Skips forward through input {\itshape code\+Part} assuming parser index points start of given part. Returns true if given {\ttfamily code\+Part} was found and index and skipped
\item {\ttfamily skip\+Identifier} -\/ Skips approached identifier (can be function name or property name), returns {\ttfamily \{ name, start, end \}} meta object
\item {\ttfamily skip\+Whitespace} -\/ Skips any whitespace and comments founds at current parsing index
\item {\ttfamily collect\+Scope} -\/ If at current index {\ttfamily (} character is found, it registers given paranthesis scope for registrations (it\textquotesingle{}s content will be returned as one of the results after finished parsing)
\item {\ttfamily stop} -\/ Stops parsing process
\item {\ttfamily index} -\/ Returns currently parsed index
\item {\ttfamily previous\+Token} -\/ Previous non-\/whitespace character
\item {\ttfamily scope\+Depth} -\/ Current scope depth
\item {\ttfamily should\+Collect\+Comments} -\/ Whether data about code comments should be collected in the result
\end{DoxyItemize}

\label{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2448}%
\Hypertarget{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2448}%
 \doxysubparagraph*{Example}

Parse all {\ttfamily require(..)} calls\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ esniff\ =\ require("{}esniff"{});}
\DoxyCodeLine{}
\DoxyCodeLine{var\ parseRequires\ =\ function\ (code)\ \{}
\DoxyCodeLine{\ \ return\ esniff(code,\ function\ (emitter)\ \{}
\DoxyCodeLine{\ \ \ \ emitter.on("{}trigger:r"{},\ function\ (accessor)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ if\ (accessor.previousToken\ ===\ "{}."{})\ return;}
\DoxyCodeLine{\ \ \ \ \ \ if\ (!accessor.skipCodePart("{}require"{}))\ return;}
\DoxyCodeLine{\ \ \ \ \ \ accessor.skipWhitespace();}
\DoxyCodeLine{\ \ \ \ \ \ accessor.collectScope();}
\DoxyCodeLine{\ \ \ \ \});}
\DoxyCodeLine{\ \ \});}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(parseRequires("{}var\ x\ =\ require('foo/bar')"{}));}
\DoxyCodeLine{[\{\ type:\ "{}scope"{},\ point:\ 17,\ column:\ 17,\ line:\ 1,\ raw:\ "{}'foo/bar'"{}\ \}];}

\end{DoxyCode}
\hypertarget{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2449}{}\doxyparagraph{\texorpdfstring{Predefined utils for common use cases}{Predefined utils for common use cases}}\label{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2449}
\hypertarget{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2450}{}\doxyparagraph{\texorpdfstring{accessed\+Properties(obj\+Name) \+\_\+(esniff/accessed-\/properties)\+\_\+}{accessed\+Properties(obj\+Name) \+\_\+(esniff/accessed-\/properties)\+\_\+}}\label{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2450}
Returns function which allows us to find all accessed property names on given object name


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ findProperties\ =\ require("{}esniff/accessed-\/properties"{});}
\DoxyCodeLine{var\ findContextProperties\ =\ findProperties("{}this"{});}
\DoxyCodeLine{}
\DoxyCodeLine{var\ result\ =\ findContextProperties(}
\DoxyCodeLine{\ \ "{}var\ foo\ =\ \(\backslash\)"{}0\(\backslash\)"{};\ this.bar\ =\ foo;\ this.someMethod();\ otherFunction()"{}}
\DoxyCodeLine{);}
\DoxyCodeLine{console.log(result);\ //\ [\ \{\ name:\ 'bar',\ start:\ 20,\ end:\ 23\ \},\ \{\ name:\ 'someMethod',\ start:\ 36,\ end:\ 46\ \}\ ]}

\end{DoxyCode}
\hypertarget{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2451}{}\doxyparagraph{\texorpdfstring{function(name\mbox{[}, options\mbox{]}) \+\_\+(esniff/function)\+\_\+}{function(name\mbox{[}, options\mbox{]}) \+\_\+(esniff/function)\+\_\+}}\label{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2451}
Returns function which allows us to find all occurrences of given function (or method) being invoked

Through options we can restrict cases which we\textquotesingle{}re after\+:


\begin{DoxyItemize}
\item {\ttfamily as\+Property} (default\+: {\ttfamily false}), on true will allow {\ttfamily x.\+name()} when we search for {\ttfamily name} calls
\item {\ttfamily as\+Plain} (default\+: {\ttfamily true}), on true it allows plain calls e.\+g. {\ttfamily name()} when we search for {\ttfamily name}. Should be set to {\ttfamily false} if we\textquotesingle{}re strictly about method calls.
\end{DoxyItemize}

Setting both {\ttfamily as\+Property} and {\ttfamily as\+Plain} to false, will always produce empty result


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ findRequires\ =\ require("{}esniff/function"{})("{}require"{});}
\DoxyCodeLine{}
\DoxyCodeLine{findRequires("{}var\ x\ =\ require('foo/bar')"{});}
\DoxyCodeLine{//\ [\{\ point:\ 17,\ column:\ 17,\ line:\ 1,\ raw:\ '\(\backslash\)'foo/bar\(\backslash\)''\ \}]}

\end{DoxyCode}
\hypertarget{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2452}{}\doxyparagraph{\texorpdfstring{resolve\+Arguments(code\mbox{[}, limit\mbox{]}) \+\_\+(esniff/resolve-\/arguments)\+\_\+}{resolve\+Arguments(code\mbox{[}, limit\mbox{]}) \+\_\+(esniff/resolve-\/arguments)\+\_\+}}\label{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2452}
Resolves expressions separated with commas, with additional {\ttfamily limit} you can specify after which number of arguments resolver should stop


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ resolveArgs\ =\ require("{}esniff/resolve-\/arguments"{});}
\DoxyCodeLine{}
\DoxyCodeLine{var\ result\ =\ resolveArgs("{}'raz',\ 'dwa',\ ['raz',\ 'dwa'],\ 'trzy'"{},\ 3);}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(result);\ //\ ['"{}raz"{}',\ '\ "{}dwa"{}',\ '\ [\(\backslash\)'raz\(\backslash\)',\ \(\backslash\)'dwa\(\backslash\)']']}

\end{DoxyCode}
\hypertarget{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2453}{}\doxysubsubsection{\texorpdfstring{Limitations}{Limitations}}\label{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2453}

\begin{DoxyItemize}
\item {\itshape esniff} assumes code that you pass is syntactically correct, it won\textquotesingle{}t inform you about any syntax errors and may produce unexpected and nonsense results when such code is used.
\item There\textquotesingle{}s single case of syntactically correct code, which will make {\itshape esniff} produce incorrect results, it\textquotesingle{}s division made directly on object literal (e.\+g. `x = \{ foo\+: \textquotesingle{}bar' \} / 14{\ttfamily , esniff in that case will assume that}/\`{} starts regular expression). Still there\textquotesingle{}s not known use case where such code may make any sense, and many popular JS source code parsers share very same vulnerability.
\end{DoxyItemize}\hypertarget{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2454}{}\doxysubsection{\texorpdfstring{Tests}{Tests}}\label{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2454}
\begin{DoxyVerb}$ npm test
\end{DoxyVerb}
 \hypertarget{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2455}{}\doxysubsection{\texorpdfstring{Security contact information}{Security contact information}}\label{md__2home_2solype_2delivery_2current__days_2Mannheim_2front_2node__modules_2esniff_2README_autotoc_md2455}
To report a security vulnerability, please use the \href{https://tidelift.com/security}{\texttt{ Tidelift security contact}}. Tidelift will coordinate the fix and disclosure. 
Server -> Client (TCP)

200 (sur 1 char) = OK
201 (sur 1 char) = KO

lister les rooms(c'est pour lister les rooms déjà existantes) :
1{
    [ID room sur 1 char][Nom room][nombre de personne dans la room]
}

chargement d'un sprite :
2[id du type de sprite][size x sur 4 octet] [size y sur 4 octet][ width à prendre sur l'image sur 4o] [height à prendre sur l'image sur 4o] [offset x 4 octets] [offset y 4 octets] [ nb frame sur 1 octet ] [ nb milisecond pour les frame / 4o]

Chargement d'un background :
3[Id background][voir precedemment]

Chargement d'une musique :
4[id musique][path to musique]

chargement d'action :
5[id action / 4o][key code / 4o][pressed 1 | released 0]

Transfert IpPort de la game où se passera le jeu :
6[IP / 4o][Port/2o][Id Player / 1o]

avec :
Ip : [nb1 /1o][nb2 /1o][nb3 /1o][nb4 /1o] => nb1.nb2.nb3.nb4
Port : [nb1/1o][nb2/1o] translation en str puis concaténation, typiquement pour 9809, NB1 = 98 et NB2 = 09 


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Protocole TCP Client -> Server
Connecter : 1
Entrer room : 2
Lancer la room : 3
Quitter la room : 4
Rename : 5
Missing image : 6
New room : 7

set name :
1[Nom]

Entrer dans la room :
2[Id room]

Lancer :
3[Rien derrière]

Quitter :
4[Rien derrière]

Rename :
5[Nouveau nom]

Missing image :
6[nom de l'image]

new room :
7[Nom de la room]


____________________________________________________________________________________________________________________

#include <iostream>
#include <unordered_map>
#include <functional>
#include <sstream>

void fonctionA(int param1, std::string param2) {
    std::cout << "Fonction A : param1 = " << param1 << ", param2 = " << param2 << "\n";
}

void fonctionB(double param) {
    std::cout << "Fonction B : param = " << param << "\n";
}

void fonctionC() {
    std::cout << "Fonction C sans paramètres\n";
}

int main() {
    // Dictionnaire de commandes
    std::unordered_map<int, std::function<void(std::istringstream&)>> commandeMap;

    commandeMap[1] = [](std::istringstream& params) {
        int param1;
        std::string param2;
        params >> param1 >> param2;
        fonctionA(param1, param2);
    };

    commandeMap[2] = [](std::istringstream& params) {
        double param;
        params >> param;
        fonctionB(param);
    };

    commandeMap[3] = [](std::istringstream&) {
        fonctionC();
    };

    // Exemple de message reçu
    std::string messageRecu = "1 42 Hello";
    std::istringstream stream(messageRecu);

    int commandeId;
    stream >> commandeId;

    if (commandeMap.find(commandeId) != commandeMap.end()) {
        commandeMap[commandeId](stream);
    } else {
        std::cout << "Commande inconnue\n";
    }

    return 0;
}


void Server::setClientAction(std::size_t id_client)
{
    // [key] [state (1 = pressed, 2 = released)] [id action that will be sent to the serv]
    // [SIZE][ACTION][ID1][ID2][ID3][ID4][KEY1][KEY2][KEY3][KEY4][pressed]
    // 
    std::vector<char> data;

    std::cout << "setClientAction" << std::endl;

    data.resize(11);
    data[0] = 11;
    data[1] = static_cast<char>(EntityOperation::ACTION);

    for (auto key_binding: _keys) {
        unsigned int id_action = key_binding.first + static_cast<unsigned int>(PREDEFINED_ACTIONS::NB_ACTIONS);
        unsigned int key_code = key_binding.second.first;
        bool pressed = key_binding.second.second;
        std::cout << "key " << key_code << " pressed: " << pressed << std::endl;

        std::memcpy(&data[2], &id_action, sizeof(id_action));
        std::memcpy(&data[6], &key_code, sizeof(key_code));
        data[10] = static_cast<char>(pressed);
        std::cout << "send action " << id_action << " to client " << id_client << std::endl;
        this->sendToClient(id_client, data);
    }
}